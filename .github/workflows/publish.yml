name: publish

on:
  push:
    tags:
      - 'v*' # e.g. v0.2.3
  workflow_dispatch:
    inputs:
      version:
        description: 'Package version (e.g., 0.2.3). Required if not running from a tag.'
        required: false
        type: string

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
      checks: write
    steps:
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'
      - name: Restore & Build
        shell: bash
        run: |
          dotnet restore
          dotnet build -c Release --no-restore
      - name: Run unit tests
        run: |
          dotnet test -c Release --no-build \
            --logger "trx;LogFileName=test_results.trx" \
            --results-directory ./test-results
      - name: Test Report
        uses: dorny/test-reporter@v2
        if: success() || failure()
        with:
          name: Unit Tests
          path: test-results/*.UnitTests.trx
          reporter: dotnet-trx
          fail-on-error: true
          list-tests: 'all'
          list-suites: 'all'
          badge-title: 'unit-tests'
          use-actions-summary: 'true'
          only-summary: 'false'
  pack-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      checks: write
      pull-requests: write
    env:
      DOTNET_NOLOGO: true
      DOTNET_CLI_TELEMETRY_OPTOUT: true
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      - name: Determine version
        id: ver
        shell: bash
        run: |
          if [[ "${GITHUB_REF_TYPE}" == "tag" ]]; then
            VERSION="${GITHUB_REF_NAME#v}"
          elif [[ -n "${{ inputs.version }}" ]]; then
            VERSION="${{ inputs.version }}"
          else
            echo "ERROR: No version provided. Run on a tag (vX.Y.Z) or pass 'version' input." >&2
            exit 1
          fi
          echo "PKG_VERSION=$VERSION" | tee -a $GITHUB_ENV
          echo "Using version: $VERSION"

      - name: Restore & Build
        shell: bash
        run: |
          dotnet restore
          dotnet build -c Release --no-restore

#      - name: Test (produce TRX for UI)
#        shell: bash
#        run: |
#          mkdir -p TestResults
#          dotnet test -c Release --no-build \
#            --logger "trx;LogFileName=test_results.trx" \
#            --results-directory ./TestResults
#
#      - name: Publish Test Results to GitHub UI
#        if: always()
#        uses: EnricoMi/publish-unit-test-result-action@v2
#        with:
#          files: |
#            TestResults/**/*.trx
#
#      - name: Upload raw TestResults (artifact)
#        if: always()
#        uses: actions/upload-artifact@v4
#        with:
#          name: test-results
#          path: TestResults

      - name: Pack CryptoStreaming.CryptoCore
        run: dotnet pack ./src/CryptoCore/CryptoCore.csproj -c Release -o ./artifacts -p:Version="$PKG_VERSION" --no-build

      - name: Pack CryptoStreaming.Abstractions
        run: dotnet pack ./src/CryptoStreaming.Abstractions/CryptoStreaming.Abstractions.csproj -c Release -o ./artifacts -p:Version="$PKG_VERSION" --no-build

      - name: Pack CryptoStreaming.Channels
        run: dotnet pack ./src/CryptoStreaming.Channels/CryptoStreaming.Channels.csproj -c Release -o ./artifacts -p:Version="$PKG_VERSION" --no-build

      - name: Pack CryptoConnector.Binance
        run: dotnet pack ./src/CryptoConnector.Binance/CryptoConnector.Binance.csproj -c Release -o ./artifacts -p:Version="$PKG_VERSION" --no-build

      - name: Prepare YC service account key
        shell: bash
        env:
          SA_KEY_JSON: ${{ secrets.YC_SA_KEY_JSON }}
        run: |
          if [ -z "$SA_KEY_JSON" ]; then
            echo "ERROR: Secret YC_SA_KEY_JSON is not set." >&2
            exit 1
          fi
          printf '%s' "$SA_KEY_JSON" > key.json
          head -n 1 key.json >/dev/null

      - name: Install Yandex Cloud CLI
        shell: bash
        run: |
          curl -sSL https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash
          echo "${HOME}/yandex-cloud/bin" >> $GITHUB_PATH

      - name: Obtain IAM token
        id: iam
        shell: bash
        run: |
          yc config profile create ci-sa
          yc config set service-account-key key.json
          IAM_TOKEN="$(yc iam create-token)"
          if [[ -z "$IAM_TOKEN" ]]; then
            echo "ERROR: Failed to obtain IAM token." >&2
            exit 1
          fi
          echo "IAM_TOKEN=$IAM_TOKEN" >> $GITHUB_ENV
          echo "token-length=${#IAM_TOKEN}"

      - name: Add YC NuGet source
        shell: bash
        run: |
          if [[ -z "${{ secrets.YC_REGISTRY_ID }}" ]]; then
            echo "ERROR: Secret YC_REGISTRY_ID is not set." >&2
            exit 1
          fi
          SRC_URL="https://registry.yandexcloud.net/nuget/v3/${{ secrets.YC_REGISTRY_ID }}/index.json"
          dotnet nuget add source "$SRC_URL" \
            -n yc-reg \
            -u "iam" \
            -p "$IAM_TOKEN" \
            --store-password-in-clear-text \
            --protocol-version 3

      - name: Verify registry access bindings (diagnostics)
        shell: bash
        env:
          REG_ID: ${{ secrets.YC_REGISTRY_ID }}
        run: |
          echo "Checking access bindings for registry: $REG_ID"
          yc cloud-registry registry list-access-bindings "$REG_ID" || {
            echo "Failed to read access bindings. The service account may not have viewer/list permissions on registry." >&2
            exit 1
          }

      - name: Push packages to Yandex Cloud Registry
        shell: bash
        env:
          IAM_TOKEN: ${{ env.IAM_TOKEN }}
        run: |
          dotnet nuget push "./artifacts/*.nupkg" -s yc-reg --api-key "$IAM_TOKEN" --skip-duplicate
          dotnet nuget push "./artifacts/*.snupkg" -s yc-reg --api-key "$IAM_TOKEN" --skip-duplicate || true

      - name: Upload packages (artifact)
        uses: actions/upload-artifact@v4
        with:
          name: nuget-packages-${{ env.PKG_VERSION }}
          path: artifacts/*.nupkg
          if-no-files-found: error
